# modern_c_study

## 3장 C언어와 객체지향
### 3.1 개요
C에서는 특정 내용을 처리하기 위해 함수라는 것이 존재하고 이를 이용해 프로그램을 구조화 할 수 있어야 한다.
이럴때 도움이 되는것이 바로 디자인 페턴이며, C언어에서 디자인 페턴을 적용하기 위해서는 객체지향을 염두에 두고 프로그래밍 할 수 있어야 한다.

### 3.2 C의 모듈화와 객체지향
#### 3.2.1 고전적인 C의 스택을 구현
고전적인 C의 스택 구현에 있어 문제가 되는 부분은 변수와 함수의 스코프이다.
전역변수 g_iStackBuff, g_iStackCount, 전역함수 isStackFull(), isStackEmpty(), stackPush(), stackPop()
위에 변수와 함수는 전역 네임스페이스에 공개가 되어 있으므로 다른 프로그램에서 동일한 이름이 있는경우 충돌하게되어 링크에러가 발생한다.
이런 문제는 staic 지시자를 이용하여 쉽게 해결할수있다. 
외부에 공개할 함수나 변수만 헤더에 선언하고 외부에 공개할 필요가 없는 변수나 함수는 static지시자를 붙이는 것이 C언어에서 모듈화 방법이다.

#### 3.2.2 구조체를 이용한 자료 구조와 로직의 분리
3.2.1절에서 구현된 스택의 경우 1개의 스택만 가질수 있다. 물론 이름을 다르게 해서 2개, 3개의 스택을 더 가질 수는 있지만 이렇게 하면 내용이 동일한 코드가 많이 생기게 된다. 이런 문제를 해결 학 위해 스택을 구현하는데 필요한 데이터를 한데 모으고 이렇게 모은 데이터를 각각 여러 개 갖게 해야해야 할 것이다.

const키워드의 위치별 의미
상수 포인터(const pointer) : 포인터 변수를 const하겠다.
~~~c
int* const ptr = &a;
ptr = &b; //포인터가 상수이므로 변경 불가능
*ptr = 300; //값은 변경 가능
~~~

상수에 대한 포인터(Pointer to Const) : int *ptr을 상수화 하겠다. 즉 ptr이 가리키는 값이 상수가 되어 값을 변경 할 수 없다.
~~~c
const int* ptr = &a;
ptr = &b; //포인터가 상수가 아니므로 변경 가능
*ptr = 300; //값은 변경 불가능
~~~

상수에 대한 상수 포인터(Const Pointer to Const) : 위 두개의 개념을 합한 의미
~~~c
const int* const ptr = &a;
ptr = &b; //포인터가 상수가 아니므로 변경 불가능
*ptr = 300; //값은 변경 불가능
~~~

#### 3.2.3 C를 이용한 객체 지향
범위 검사 기능을 가진 스택 구현
